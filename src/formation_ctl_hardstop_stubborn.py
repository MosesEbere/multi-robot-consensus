#!/usr/bin/python3

"""
Dev Notes:
- Final formation and scale velocity parameters are now included in the initialization of the Reynolds class.
- The get_desired_formation method was added to get the desired formation based on the final formation parameters 
    - parameters are controlled from the config file.
- The shape_function method was added to dynamically call the formation method to get the desired formation.
- The normalize_positions method was added to normalize positions to fall within the map dimensions specified during initialization.
- The task_function method was added to dynamically call the graph method to get the desired task.
- The run method was modified to perform the task and update the stubborn nodes' goal if there are any.
- Since we need velocities instead of positions to move the stubborn agents, the old positions are stored and with the new positions
    from the update_goal method, the velocities are calculated (using scale * (new position - old position)) and published.

11-02-2024 - Moses
- We were previously using the position generated by the stubborn agent class to update the position of the stubborn agent in the graph. This was wrong.
    - We should use the position generated by the stubborn agent class to update the velocity ONLY of the stubborn agent in the graph.

TODO:
- Work on the simuations in RViz.
- Work on the visualization of the stubborn agents.
"""

import rospy
from nav_msgs.msg import Odometry, Path
from nav_msgs.msg import OccupancyGrid
from std_msgs.msg import Header, ColorRGBA
from geometry_msgs.msg import Pose, Point, Quaternion, Vector3, Twist, PoseStamped
from visualization_msgs.msg import Marker, MarkerArray
import numpy as np

from utils.state_tf  import pose_msg_to_state
from utils.potential_field import PotentialField
from utils.steer_to_avoid import SteerToAvoid
from utils.navigation import Navigate
from collections import defaultdict

from utils.utils import *
from utils.Graph import Graph

import tf
import copy


from utils.init_pos import Formation


class Reynolds:
    def __init__(self):
        # ROS initialization
        rospy.init_node('reynolds', anonymous=True)
        self.rate = rospy.Rate(10) # 10hz

        # Initial Formation
        self.formation = rospy.get_param("~init_formation/init_formation")
        self.n = rospy.get_param("~init_formation/n")
        self.r = rospy.get_param("~init_formation/r")
        self.origin = rospy.get_param("~init_formation/origin")
        self.bounds = rospy.get_param("~init_formation/bounds")

        # Final Formation
        self.shape_formation = rospy.get_param("~final_formation/shape")
        self.formation_center = rospy.get_param("~final_formation/center")
        self.formation_radius = rospy.get_param("~final_formation/radius")
        self.formation_spacing = rospy.get_param("~final_formation/spacing")
        self.formation_start = rospy.get_param("~final_formation/start")
        self.final_formation_args = {'center': self.formation_center, 'radius': self.formation_radius, 'sides': copy.deepcopy(self.n), 
                                     'spacing': self.formation_spacing, 'start': self.formation_start}
        self.formation_positions_ = None

        # Communication
        self.comm_range = rospy.get_param("~comm_range")
        self.comm_theta = np.deg2rad(rospy.get_param("~comm_theta"))

        # Stubborn nodes
        self.k = rospy.get_param("~stubborn_nodes/k")
        self.stubborn_nodes = list(range(self.n, self.n+self.k))
        self.stubborn_pos = rospy.get_param("~stubborn_nodes/pos")
        self.connection = rospy.get_param("~stubborn_nodes/connection")
        self.stubborn_motion_type = rospy.get_param("~stubborn_nodes/motion_type")

        # Multigoal
        self.use_multigoal = rospy.get_param("~stubborn_nodes/use_multigoal")
        if self.use_multigoal:
            self.stubborn_pos_list = rospy.get_param("~stubborn_nodes/pos_list")
            #pop the first goal to be used as the initial goal of the stubborn agent
            self.stubborn_pos = self.stubborn_pos_list.pop(0)
            print(f'first goal: {self.stubborn_pos}')
            self.goal = copy.deepcopy(self.stubborn_pos)

        # Weighting
        self.s_w = rospy.get_param("~weights/separation")
        self.f_w = rospy.get_param("~weights/formation")
        self.sta_w = rospy.get_param("~weights/steer_to_avoid")

        # Separation
        self.separation_threshold = rospy.get_param("~separation/threshold")
        self.repulsion_strength = rospy.get_param("~separation/repulsion_strength")

        self.scale_vel = rospy.get_param("~scale_vel")
        self.priority_list = rospy.get_param('~priority_list')
        self.use_prioritized_acc = rospy.get_param('~use_prioritized_acc')

        self.map_dimensions = {'min_x': -5, 'max_x': 5, 'min_y': -5, 'max_y': 5}
        self.goal_radius = rospy.get_param('~goal_radius')

        #arguments that are passed to task function
        self.task = rospy.get_param("~task")
        self.task_args = {'speed': 0.5, 'tolerance': 0.1, 'epsilon': self.get_desired_formation()}

        self.all_behaviors = self.create_behavior_dictionary()

        # ____________________________  Instantiate Graph  ____________________________
        self.graph = self.initialize_graph()
        print(f'Graph initialized: {self.graph.is_graph_init()}')

# -------------------------------------OTHER PARAMS------------------------------------

        # Graph params
        self.n_boids = self.n + self.k
        self.inter_connectivity = rospy.get_param('~inter_connectivity')
        self.connect_k = self.k

        # Goal
        self.goal = copy.deepcopy(self.stubborn_pos)

        # Obstacle params
        self.obs_r = rospy.get_param('~obs_r')
        self.step_angle = rospy.get_param('~step_angle')
        self.max_steering_angle = rospy.get_param('~max_steering_angle')
        
        # Boid Dynamics Params
        self.max_speed = rospy.get_param('~max_speed')
        self.max_acc = rospy.get_param('~max_acc')
        self.boid_vels = {i: None for i in range(self.n_boids)}
        self.old_formation_vels = {i: (0.0, 0.0) for i in range(self.n_boids)}

        print(TextColors.GREEN + f"n_boids: {self.n_boids}" + TextColors.RESET)
        print(TextColors.GREEN + f"inter_connectivity: {self.inter_connectivity}: {self.connect_k}" + TextColors.RESET)
        print(TextColors.GREEN + f"goal: {self.goal}" + TextColors.RESET)
        print(TextColors.GREEN + f"obstacle avoidance [{self.obs_r},{self.step_angle},{self.max_steering_angle}]" + TextColors.RESET)

        # ____________________________  Obstacle Avoidance  ____________________________
        self.avoid_obstacles = PotentialField(self.obs_r)
        self.steer_to_avoid = SteerToAvoid(self.obs_r,self.step_angle,self.max_steering_angle)

        # ____________________________  Initialize ROS Components  ____________________________
        self.initialize_ros_components()

        # ____________________________ Subs/Pubs  ____________________________

        # Create subscribers and publishers to n robots dynamically
        self.subs = []
        self.pubs = []
        for i in range(self.n_boids):

            sub = rospy.Subscriber('/robot_{}/odom'.format(i), Odometry, self.odom_callback, callback_args=i)
            self.subs.append(sub)

            pub = rospy.Publisher('/robot_{}/cmd_vel'.format(i), Twist, queue_size=1)
            self.pubs.append(pub)            

        # subscribe to map
        self.map_subscriber = rospy.Subscriber("/map", OccupancyGrid, self.map_cb)

        # ____________________________  main execution  ____________________________ 
        rospy.Timer(rospy.Duration(0.05), self.run)

        #____________________________   visualize   ____________________________

        self.map_msg = None
        self.map_dilated = False

        self.boids_markers_pub = rospy.Publisher("/vis/boid_positions", MarkerArray,queue_size=1) 
        self.dilated_obs_pub = rospy.Publisher("/vis/obstacle_dilated", OccupancyGrid, queue_size=1)
        self.goal_pub = rospy.Publisher("/vis/goal", Marker, queue_size=1)
        self.edges_pub = rospy.Publisher('vis/edges', Marker, queue_size=1)

        self.boids_markers = MarkerArray()
        self.boids_markers.markers = []

        self.formation_markers = MarkerArray()
        self.formation_markers.markers = []

        self.desired_formation_pub = rospy.Publisher("/vis/desired_formation", MarkerArray,queue_size=1) 

        if rospy.get_param('~visualize'):
            rospy.Timer(rospy.Duration(0.05), self._visualize) # 20fps

    def initialize_graph(self):
        # Create Graph
        G = Graph(self.formation, params=[copy.deepcopy(self.n), self.r, self.origin, self.bounds], comm_range=self.comm_range, directed=True, 
                  comm_theta=self.comm_theta, stubborn_pos=self.stubborn_pos, stubborn_nodes=self.stubborn_nodes, 
                  connection=self.connection, map_dimensions=self.map_dimensions, scale_vel=self.scale_vel)
        return G
    
    def create_behavior_dictionary(self):
        # Create a dictionary of all behaviors
        return [
            '_separation', 
            '_formation', 
            '_steer_to_avoid', 
        ]
    
    def get_desired_formation(self):
        if self.k == 0:
            positions_ = self.shape_function(Formation(self.n, self.k), self.shape_formation, self.final_formation_args, stubborn_agents=False) 
        else:
            positions_ = self.shape_function(Formation(self.n, self.k), self.shape_formation, self.final_formation_args)

        epsilon = np.array(positions_)
        return epsilon

    def task_function(self, graph_class: Graph, name, args):
        '''
        Dynamically calls the graph method to get the desired task.
        '''
        if name == 'rendezvous' or name == 'discrete_consensus':
            return getattr(graph_class, name)(speed=args['speed'], tolerance=args['tolerance'])
        return getattr(graph_class, name)(epsilon=args['epsilon'])
    
    def shape_function(self, formation_class: Formation, name, args, stubborn_agents=True):
        '''
        Dynamically calls the formation method to get the desired formation.
        '''
        if name == 'line_formation' or name == 'square_formation' or name == 'triangle_formation':
            return getattr(formation_class, name)(start=args['start'], spacing=args['spacing'], stubborn_agents=stubborn_agents)
        elif name == 'circle_formation':
            return getattr(formation_class, name)(center=args['center'], radius=args['radius'], stubborn_agents=stubborn_agents)
        return getattr(formation_class, name)(center=args['center'], radius=args['radius'], sides=args['sides'], stubborn_agents=stubborn_agents)

    def normalize_positions(self, positions: list) -> list:
        """
        Normalize positions to fall within the map dimensions specified during initialization.

        Args:
            positions (list): A list of (x, y) tuples representing positions.

        Returns:
            list: A list of normalized (x, y) tuples.
        """
        normalized_positions = [(x / self.bounds[1] * (self.map_dimensions['max_x'] - self.map_dimensions['min_x']) + self.map_dimensions['min_x'],
                                 (self.bounds[0] - y) / self.bounds[0] * (self.map_dimensions['max_y'] - self.map_dimensions['min_y']) + self.map_dimensions['min_y'])
                                for x, y in positions]
        return normalized_positions
    
    def create_desired_formation(self, stubborn_agents=True) -> list:
        """
        Create the desired formation based on the positions of the stubborn agents and the formation positions.

        Args:
            stubborn_agent_positions (list): A list of (x, y) tuples representing the positions of the stubborn agents.
            formation_positions (list): A list of (x, y) tuples representing the positions of the formation.

        Returns:
            list: A list of (x, y) tuples representing the desired formation.
        """
        # NOTE: The following helps to retrieve the desired formation based on the positions of a selected anchor agent.
        # The anchor agent is the last agent in the list of stubborn agents. This helps to compare actual formation to desired formation.
        if not stubborn_agents:
            # NOTE: The following is simply a reversal of the original functions for creating the formation. 
            if  self.shape_formation == 'circle_formation' or self.shape_formation == 'polygon_formation':
                angles = np.linspace(0, 2 * np.pi, self.n, endpoint=False)
                formation_center = (self.graph.positions[self.n + self.k - 1][0] - np.cos(angles[self.n + self.k - 1]) * self.formation_radius, 
                                    self.graph.positions[self.n + self.k - 1][1] - np.sin(angles[self.n + self.k - 1]) * self.formation_radius)
                final_formation_args = {'center': formation_center, 'radius': self.formation_radius, 'sides': copy.deepcopy(self.n), 
                                            'spacing': self.formation_spacing, 'start': self.formation_start}   
            elif self.shape_formation == 'line_formation':
                formation_start = (self.graph.positions[self.n + self.k - 1][0] - (self.n + self.k - 1) * self.formation_spacing, self.graph.positions[self.n + self.k - 1][1])
                final_formation_args = {'start': formation_start, 'spacing': self.formation_spacing, 'stubborn_agents': False}
            elif self.shape_formation == 'triangle_formation':
                rows = int((-1 + np.sqrt(1 + 8 * self.n)) / 2)
                remaining = self.n - rows * (rows + 1) // 2
                formation_start = (self.graph.positions[self.n + self.k - 1][0] - (remaining + 2) * self.formation_spacing, self.graph.positions[self.n + self.k - 1][1] - (rows - 1) * self.formation_spacing)
                final_formation_args = {'start': formation_start, 'spacing': self.formation_spacing, 'stubborn_agents': False}
            elif self.shape_formation == 'square_formation':
                side_length = np.ceil(np.sqrt(self.n))
                formation_start = (self.graph.positions[self.n + self.k - 1][0] - (self.n + self.k - 1) % side_length * self.formation_spacing, self.graph.positions[self.n + self.k - 1][1] - (self.n + self.k - 1) // side_length * self.formation_spacing)
                final_formation_args = {'start': formation_start, 'spacing': self.formation_spacing, 'stubborn_agents': False}
            positions_ = self.shape_function(Formation(self.n, self.k), self.shape_formation, final_formation_args, stubborn_agents=False) 
        else:
            # TODO: Clean this up! Only circle and polygon are working as required.
            if  self.shape_formation == 'circle_formation' or self.shape_formation == 'polygon_formation':
                final_formation_args = {'center': self.graph.positions[self.n + self.k - 1], 'radius': self.formation_radius, 'sides': copy.deepcopy(self.n), 
                                            'spacing': self.formation_spacing, 'start': self.formation_start}
                positions_ = self.shape_function(Formation(self.n, self.k), self.shape_formation, final_formation_args, stubborn_agents=True) 
            elif self.shape_formation == 'line_formation':
                final_formation_args = {'start': self.graph.positions[self.n + self.k - 1], 'spacing': self.formation_spacing, 'stubborn_agents': True}
                positions_ = self.shape_function(Formation(self.n, self.k), self.shape_formation, final_formation_args, stubborn_agents=True)
            elif self.shape_formation == 'triangle_formation':
                final_formation_args = {'start': self.graph.positions[self.n + self.k - 1], 'spacing': self.formation_spacing, 'stubborn_agents': True}
                positions_ = self.shape_function(Formation(self.n, self.k), self.shape_formation, final_formation_args, stubborn_agents=True)
            elif self.shape_formation == 'square_formation':
                final_formation_args = {'start': self.graph.positions[self.n + self.k - 1], 'spacing': self.formation_spacing, 'stubborn_agents': True}
                positions_ = self.shape_function(Formation(self.n, self.k), self.shape_formation, final_formation_args, stubborn_agents=True)
        self.formation_positions_ = positions_
        return positions_
    
    def is_goal_reached(self, new_pos, old_pos):
        """
        Check if the new position is within the goal radius of the old position.

        Parameters:
        new_pos (tuple): The new position coordinates.
        old_pos (tuple): The old position coordinates.

        Returns:
        bool: True if the new position is within the goal radius, False otherwise.
        """
        dist = np.linalg.norm(np.array(new_pos) - np.array(old_pos))
        print(f"Distance: {dist}")
        if dist < self.goal_radius:
            return True
        return False

    #______________________________ callbacks  _________________________
    def odom_callback(self, data, robot_id):
        '''
        Takes odom msg and robot id, and creates boids if not created.
        Otherwise, updates the state of the boid.
        '''
        x = pose_msg_to_state(data)
        v = x[-3:-1]
        x = x[:2]
        self.graph.set_position(robot_id,x)
        self.boid_vels[robot_id] = v

    def map_cb(self, gridmap):
        env = np.array(gridmap.data).reshape(gridmap.info.height, gridmap.info.width).T
        # Set avoid obstacles - The steer to avoid behavior (IN THE DICTIONARY) requires the map, resolution, and origin
        self.steer_to_avoid.set(data=env, 
                                resolution=gridmap.info.resolution, 
                                origin=[gridmap.info.origin.position.x, gridmap.info.origin.position.y])
        self.map_msg = gridmap         
            
    def run(self, event):
        if self.graph.is_graph_init():        

            #### Formation Control ####
            # Perform the task    
            self.task_function(self.graph, self.task, self.task_args)

            if self.k > 0 and self.task == 'formation_consensus': # If there are stubborn nodes, update their goal.

                # Extract the last position of the stubborn agents - there are k stubborn agents
                prev_stubborn_pos = [self.graph.positions[i] for i in range(self.n, self.n + self.k)]

                new_stubborn_pos = self.graph.stubborn_agent.update_goal(self.stubborn_motion_type)
                if self.formation_positions_ is None:
                    self.create_desired_formation()

                #we need to publish velocities
                self.graph.update_connectivity()
            # we need velocities instead of position.
            # positions = self.graph.get_positions()
            formation_forces = self.graph.get_velocities()

            if self.k == 0 and self.formation_positions_ is None:
                self.create_desired_formation(stubborn_agents=False)

            # Replace the velocities of the stubborn agents with the scale * (new position - old position)
            if self.k > 0:
                for i in range(self.n, self.n + self.k):
                    formation_forces[i] = self.scale_vel * (np.array(new_stubborn_pos[i - self.n]) - np.array(prev_stubborn_pos[i - self.n]))


            #### Separation ####
            separation_forces = self.graph.calculate_separation_forces(separation_threshold=self.formation_spacing*self.separation_threshold, 
                                                                       repulsion_strength=self.repulsion_strength)

            #### Obstacle Avoidance ####
            steering_forces = defaultdict(self.default_value)
            for node_id in self.graph.G.nodes():
                    # NOTE: Since the stubborn agents are VISIBLE, we need them to avoid obstacles as well. 
                # if not(self.graph.is_stubborn(node_id)):
                    current_poses = self.graph.get_positions()  
                    current_pos = np.array(current_poses[node_id])
                    if node_id == self.n + self.k - 1: 
                        # velocity = formation_forces[node_id]
                        velocity = self.boid_vels[node_id]
                    else:
                        velocity = formation_forces[node_id]
                        # velocity = self.boid_vels[node_id]
                    # velocity = self.boid_vels[node_id]
                    # velocity = self.old_formation_vels[node_id]
                    # velocity = formation_forces[node_id]
                    steering = self.steer_to_avoid._steer_to_avoid(current_pos, velocity)
                    # steering = self.avoid_obstacles._avoid_obstacles(current_pos, steering)
                    steering_forces[node_id] = steering

            vels = defaultdict(self.default_value)
            for node_id in self.graph.G.nodes():
                separation_force = separation_forces.get(node_id, np.zeros(2))  # Default to [0, 0] if not found

                # Combine the forces
                # if node_id == self.n + self.k -1: print(f"{TextColors.YELLOW}Formation: {formation_forces[node_id]}{TextColors.RESET}")
                forces = {'_formation': self.f_w * formation_forces[node_id], '_separation': self.s_w * separation_force, '_steer_to_avoid': self.sta_w * steering_forces[node_id]}
                combined_force = combine_behaviors(behavior_list=self.priority_list, force_dict=forces, use_prioritized_acc=self.use_prioritized_acc, max_acc=self.max_acc, all_behaviors=self.all_behaviors)
                # print(f"{TextColors.YELLOW}Combined: {combined_force}{TextColors.RESET}")
                # combined_force = np.tanh(self.f_w * formation_forces[node_id]) + np.tanh(self.s_w * separation_force) + np.tanh(self.sta_w * steering_forces[node_id])
                vels[node_id] = combined_force

            # Update the stubborn nodes' goal if there are any.
            if self.use_multigoal and self.is_goal_reached(self.goal,  prev_stubborn_pos[0]):
                if len(self.stubborn_pos_list) > 0:
                    # self.graph.stubborn_agent.set_goal(self.stubborn_pos_list.pop(0))
                    self.stubborn_pos = self.stubborn_pos_list.pop(0)
                    self.goal = copy.deepcopy(self.stubborn_pos)
                    self.graph.set_stubborn_pos(copy.deepcopy(self.stubborn_pos))
                    self.graph.stubborn_agent.set_stubborn_center(copy.deepcopy(self.stubborn_pos))
                    # update final formation args
                    self.final_formation_args['center'] = copy.deepcopy(self.stubborn_pos)
                    self.task_args['epsilon'] = self.get_desired_formation()
                    print(f'New goal: {self.graph.get_stubborn_pos()}')
                else:
                    print('All goals reached')

            self.old_formation_vels = formation_forces

            for boid, v in vels.items():
                # if not(self.graph.is_stubborn(boid)):
                if self.is_goal_reached(self.goal,  prev_stubborn_pos[0]):# and boid == self.n + self.k - 1 and self.k > 0:
                    self.publish_cmd_vel(boid, [0.0, 0.0])
                else:
                    self.publish_cmd_vel(boid, v)

            self.rate.sleep()

    #_______________________________  Publishers and Viz  _________________________
    def publish_cmd_vel(self, boid, vel):
        # Make cmd_vel a Twist message
        cmd_vel = Twist()
        cmd_vel.linear.x = vel[0]
        cmd_vel.linear.y = vel[1]
        # Publish to the appropriate topic
        self.pubs[boid].publish(cmd_vel)

    def publish_boid_trajectory(self):
        for i, boid in enumerate(self.boids):
            pose = PoseStamped()
            pose.header.frame_id = "map"
            pose.header.stamp = rospy.Time.now()
            pose.pose.position.x = boid.get_pos()[0]
            pose.pose.position.y = boid.get_pos()[1]
            pose.pose.position.z = 0
            # convert the yaw angle to a euler to quaternion
            quaternion = tf.transformations.quaternion_from_euler(0.0, 0.0, boid.get_theta())
            pose.pose.orientation.x = quaternion[0]
            pose.pose.orientation.y = quaternion[1]
            pose.pose.orientation.z = quaternion[2]
            pose.pose.orientation.w = quaternion[3]
        
            #the trajectory is a linestrip marker
            self.boid_traj[i].points.append(pose.pose.position)
            self.traj_pub[i].publish(self.boid_traj[i])
        pass


    def initialize_ros_components(self):
        # Initialize ROS subscribers and publishers
        #define a path message for each boid
        self.boid_path = [Path() for i in range(self.n_boids)]
        self.boid_traj = [Marker() for i in range(self.n_boids)]
        #define a publisher for the linestrip trajectory of each boid
        self.traj_pub = [rospy.Publisher('/robot_{}/trajectory'.format(i), Marker, queue_size=1)
                        for i in range(self.n_boids)]
        
        #create an array of different random RGBA colors to be used for each boid path trajectory
        self.traj_colors = [ColorRGBA(np.random.rand(), np.random.rand(), np.random.rand(), 1.0) for i in range(self.n_boids)]
        
        #define some basic attributes of the path message
        for i in range(self.n_boids):
            #basic path attributes
            self.boid_path[i].header.frame_id = "map"
            self.boid_path[i].header.stamp = rospy.Time.now()

            #basic marker trajectory attributes
            self.boid_traj[i].header.frame_id = "map"
            self.boid_traj[i].header.stamp = rospy.Time.now()
            self.boid_traj[i].type = Marker.LINE_STRIP
            self.boid_traj[i].action = Marker.ADD
            self.boid_traj[i].lifetime = rospy.Duration(423864)
            self.boid_traj[i].scale.x = 0.05
            self.boid_traj[i].color = self.traj_colors[i]
        
    def _visualize(self, event):
        self.boids_markers.markers = []

        # get a dict of positions as id: (x,y)
        positions = self.graph.get_positions()
        n = self.graph.get_num_nodes()

        # Extra pos and leader data from boids
        stubborn_list = [1 if self.graph.is_stubborn(i) else 0 
                         for i in range(n)]

        # Ensure that all boids have been initialized in graph with proper positions
        if not(self.graph.is_graph_init()):
            return
        
        for i in range(n):
            # create boid markers
            marker = Marker(
                header=Header(frame_id="map"),
                type=Marker.SPHERE,
                action=Marker.ADD,
                pose=Pose(Point(*positions[i], 0), Quaternion(0, 0, 0, 1)),
                # red for leader, blue for normal
                color=ColorRGBA(stubborn_list[i], 0, 1-stubborn_list[i], 1),
                scale=Vector3(0.2, 0.2, 0.2),
                lifetime=rospy.Duration(0),
            )
            marker.id = i
            self.boids_markers.markers.append(marker)
        self.boids_markers_pub.publish(self.boids_markers)

        # edges
        edges = self.graph.get_edges()
        edge_marker = Marker(
                header=Header(frame_id="map"),
                type=Marker.LINE_LIST,
                action=Marker.ADD,
                color=ColorRGBA(0.1, 0.7, 0.1, 1),
                scale=Vector3(0.1, 0.1, 0.1),
                lifetime=rospy.Duration(0),
                id = 0,
                ns = "lines"
            )
        pts = []
        for e in edges:
            u, v = positions[e[0]], positions[e[1]]
            pts.append(Point(u[0], u[1], 0))
            pts.append(Point(v[0], v[1], 0))
        edge_marker.points = pts
        self.edges_pub.publish(edge_marker)

        # Desired Formation Positions
        if self.formation_positions_ is not None:
            positions_ = self.create_desired_formation()
            a = n if self.k == 0 else n-1
            for i in range(a):
                # create boid markers
                marker = Marker(
                    header=Header(frame_id="map"),
                    type=Marker.SPHERE,
                    action=Marker.ADD,
                    pose=Pose(Point(*positions_[i], 0), Quaternion(0, 0, 0, 1)),
                    # Make the color purple
                    color = ColorRGBA(1, 0, 1, 1),
                    # color=ColorRGBA(0, 0, 1, 0.5),
                    scale=Vector3(0.2, 0.2, 0.2),
                    lifetime=rospy.Duration(0),
                )
                marker.id = i 
                self.formation_markers.markers.append(marker)
            self.desired_formation_pub.publish(self.formation_markers)

        # publish goal 
        marker = Marker(
                header=Header(frame_id="map"),
                type=Marker.CYLINDER,
                action=Marker.ADD,
                pose=Pose(Point(*[self.goal[0], self.goal[1]], 0), Quaternion(0, 0, 0, 1)),
                # red for leader, blue for normal
                color=ColorRGBA(1, 1, 0, 0.4),
                
                scale=Vector3(self.goal_radius*2, self.goal_radius*2, 0.3),
                lifetime=rospy.Duration(0),
            )
        self.goal_pub.publish(marker)

        #___________________  Publish map  ___________________
        self.dilated_obs_pub.publish(self.map_msg)

    def default_value(self):
        return np.array([0, 0])

if __name__ == '__main__':
    rospy.init_node('reynolds', anonymous=True)
    try:
        node = Reynolds()
        rospy.spin()
    except rospy.ROSInterruptException:
        pass