#!/usr/bin/python3

"""
Dev Notes:
- Final formation and scale velocity parameters are now included in the initialization of the Reynolds class.
- The get_desired_formation method was added to get the desired formation based on the final formation parameters 
    - parameters are controlled from the config file.
- The shape_function method was added to dynamically call the formation method to get the desired formation.
- The normalize_positions method was added to normalize positions to fall within the map dimensions specified during initialization.
- The task_function method was added to dynamically call the graph method to get the desired task.
- The run method was modified to perform the task and update the stubborn nodes' goal if there are any.
- Since we need velocities instead of positions to move the stubborn agents, the old positions are stored and with the new positions
    from the update_goal method, the velocities are calculated (using scale * (new position - old position)) and published.

11-02-2024 - Moses
- We were previously using the position generated by the stubborn agent class to update the position of the stubborn agent in the graph. This was wrong.
    - We should use the position generated by the stubborn agent class to update the velocity ONLY of the stubborn agent in the graph.

TODO:
- Work on the simuations in RViz.
- Work on the visualization of the stubborn agents.
"""

import rospy
from std_msgs.msg import String
from nav_msgs.msg import Odometry, Path
from nav_msgs.msg import OccupancyGrid
from std_msgs.msg import Header, ColorRGBA
from geometry_msgs.msg import Pose, Point, Quaternion, Vector3, Twist, PoseStamped
from visualization_msgs.msg import Marker, MarkerArray
import numpy as np

from utils.state_tf  import pose_msg_to_state
from utils.potential_field import PotentialField
from utils.steer_to_avoid import SteerToAvoid
from utils.navigation import Navigate

from utils.utils import *
from utils.Graph import Graph

import tf
import copy


from utils.init_pos import Formation


class Reynolds:
    def __init__(self):
        # ROS initialization
        rospy.init_node('reynolds', anonymous=True)
        self.rate = rospy.Rate(10) # 10hz

        # Initial Formation
        self.formation = rospy.get_param("~init_formation/init_formation")
        self.n = rospy.get_param("~init_formation/n")
        self.r = rospy.get_param("~init_formation/r")
        self.origin = rospy.get_param("~init_formation/origin")
        self.bounds = rospy.get_param("~init_formation/bounds")

        # Final Formation
        self.shape_formation = rospy.get_param("~final_formation/shape")
        self.formation_center = rospy.get_param("~final_formation/center")
        self.formation_radius = rospy.get_param("~final_formation/radius")
        self.formation_spacing = rospy.get_param("~final_formation/spacing")
        self.formation_start = rospy.get_param("~final_formation/start")
        self.final_formation_args = {'center': self.formation_center, 'radius': self.formation_radius, 'sides': copy.deepcopy(self.n), 
                                     'spacing': self.formation_spacing, 'start': self.formation_start}

        # Communication
        self.comm_range = rospy.get_param("~comm_range")
        self.comm_theta = np.deg2rad(rospy.get_param("~comm_theta"))

        # Stubborn nodes
        self.k = rospy.get_param("~stubborn_nodes/k")
        self.stubborn_nodes = list(range(self.n, self.n+self.k))
        self.stubborn_pos = rospy.get_param("~stubborn_nodes/pos")
        self.connection = rospy.get_param("~stubborn_nodes/connection")
        self.stubborn_motion_type = rospy.get_param("~stubborn_nodes/motion_type")

        self.scale_vel = rospy.get_param("~scale_vel")

        self.map_dimensions = {'min_x': -5, 'max_x': 5, 'min_y': -5, 'max_y': 5}
        self.goal_radius = rospy.get_param('~goal_radius')


        #arguments that are passed to task function
        self.task = rospy.get_param("~task")
        self.task_args = {'speed': 0.5, 'tolerance': 0.1, 'epsilon': self.get_desired_formation()}

        #NOTE: SOME OLD PARAMETERS#
        # ____________________________  Instantiate Graph  
        # Initialize Graph
        self.G = self.initialize_graph()
        print(f'Graph initialized: {self.G.is_graph_init()}')
        # self.G = self.G #NOTE: Don't know if Khawaja is using this to plot, I had to leave it



# -------------------------------------OLD CODE------------------------------------

        # Graph params
        self.n_boids = self.n + self.k
        self.inter_connectivity = rospy.get_param('~inter_connectivity')
        self.connect_k = self.k

        # Goal
        # self.goal = rospy.get_param('~goal')
        self.goal = rospy.get_param("~stubborn_nodes/pos")

        # Obstacle params
        self.obs_r = rospy.get_param('~obs_r')
        self.step_angle = rospy.get_param('~step_angle')
        self.max_steering_angle = rospy.get_param('~max_steering_angle')
        
        # Boid Dynamics Params
        self.max_speed = rospy.get_param('~max_speed')
        self.max_acc = rospy.get_param('~max_acc')

        print(TextColors.GREEN + f"n_boids: {self.n_boids}" + TextColors.RESET)
        print(TextColors.GREEN + f"inter_connectivity: {self.inter_connectivity}: {self.connect_k}" + TextColors.RESET)
        print(TextColors.GREEN + f"goal: {self.goal}" + TextColors.RESET)
        print(TextColors.GREEN + f"obstacle avoidance [{self.obs_r},{self.step_angle},{self.max_steering_angle}]" + TextColors.RESET)

        # ____________________________  Instantiate Graph  ____________________________

        # # list of poses [x,v] for bois in neigborhood. Robot id = list index
        # self.G = Graph(n = self.n_boids, 
        #                    connect = self.inter_connectivity, 
        #                    connect_k = self.connect_k)
        # self.G.add_stubborn(self.goal)

        # ____________________________  Obstacle Avoidance  ____________________________
        # self.avoid_obstacles = PotentialField(self.obs_r)
        self.avoid_obstacles = SteerToAvoid(self.obs_r,self.step_angle,self.max_steering_angle)

        # ____________________________  Initialize ROS Components  ____________________________
        self.initialize_ros_components()

        # ____________________________ Subs/Pubs  ____________________________

        # Create subscribers and publishers to n robots dynamically
        self.subs = []
        self.pubs = []
        for i in range(self.n_boids):

            sub = rospy.Subscriber('/robot_{}/odom'.format(i), Odometry, self.odom_callback, callback_args=i)
            self.subs.append(sub)

            pub = rospy.Publisher('/robot_{}/cmd_vel'.format(i), Twist, queue_size=1)
            self.pubs.append(pub)            

        # subscribe to map
        self.map_subscriber = rospy.Subscriber("/map", OccupancyGrid, self.map_cb)

        # ____________________________  main execution  ____________________________ 
        rospy.Timer(rospy.Duration(0.05), self.run)

        #____________________________   visualize   ____________________________

        self.map_msg = None
        self.map_dilated = False

        self.boids_markers_pub = rospy.Publisher("/vis/boid_positions", MarkerArray,queue_size=1) 
        self.dilated_obs_pub = rospy.Publisher("/vis/obstacle_dilated", OccupancyGrid, queue_size=1)
        self.goal_pub = rospy.Publisher("/vis/goal", Marker, queue_size=1)
        self.edges_pub = rospy.Publisher('vis/edges', Marker, queue_size=1)

        self.boids_markers = MarkerArray()
        self.boids_markers.markers = []

        if rospy.get_param('~visualize'):
            rospy.Timer(rospy.Duration(0.05), self._visualize) # 20fps
        

    def initialize_graph(self):
        # Create Graph
        G = Graph(self.formation, params=[copy.deepcopy(self.n), self.r, self.origin, self.bounds], comm_range=self.comm_range, directed=True, 
                  comm_theta=self.comm_theta, stubborn_pos=self.stubborn_pos, stubborn_nodes=self.stubborn_nodes, 
                  connection=self.connection, map_dimensions=self.map_dimensions, scale_vel=self.scale_vel)
        return G
    
    def get_desired_formation(self):
        if self.k == 0:
            positions_ = self.shape_function(Formation(self.n, self.k), self.shape_formation, self.final_formation_args, stubborn_agents=False) 
            # positions_ = self.normalize_positions(positions_)
        else:
            positions_ = self.shape_function(Formation(self.n, self.k), self.shape_formation, self.final_formation_args)
            # print(f'positions-before: {positions_}')
            # positions_ = self.normalize_positions(positions_)
            # print(f'positions-after: {positions_}')

        epsilon = np.array(positions_)
        return epsilon

    #NOTE: My implemented run function. 
    # Khawaja's code has to be edited
    # def run(self):
    #     while not rospy.is_shutdown():
    #         # Perform the task    
    #         self.task_function(self.G, self.task, self.task_args)

    #         if self.k > 0 and self.task == 'formation_consensus': # If there are stubborn nodes, update their goal.
    #             self.G.positions = self.G.stubborn_agent.update_goal(self.stubborn_motion_type)
    #             self.G.update_connectivity()

    #         positions = self.G.get_positions()

    #         self.rate.sleep()


    def task_function(self, graph_class: Graph, name, args):
        '''
        Dynamically calls the graph method to get the desired task.
        '''
        if name == 'rendezvous' or name == 'discrete_consensus':
            return getattr(graph_class, name)(speed=args['speed'], tolerance=args['tolerance'])
        return getattr(graph_class, name)(epsilon=args['epsilon'])
    
    def shape_function(self, formation_class: Formation, name, args, stubborn_agents=True):
        '''
        Dynamically calls the formation method to get the desired formation.
        '''
        if name == 'line_formation' or name == 'square_formation' or name == 'triangle_formation':
            return getattr(formation_class, name)(start=args['start'], spacing=args['spacing'], stubborn_agents=stubborn_agents)
        elif name == 'circle_formation':
            return getattr(formation_class, name)(center=args['center'], radius=args['radius'], stubborn_agents=stubborn_agents)
        return getattr(formation_class, name)(center=args['center'], radius=args['radius'], sides=args['sides'], stubborn_agents=stubborn_agents)


    def normalize_positions(self, positions: list) -> list:
        """
        Normalize positions to fall within the map dimensions specified during initialization.

        Args:
            positions (list): A list of (x, y) tuples representing positions.

        Returns:
            list: A list of normalized (x, y) tuples.
        """
        normalized_positions = [(x / self.bounds[1] * (self.map_dimensions['max_x'] - self.map_dimensions['min_x']) + self.map_dimensions['min_x'],
                                 (self.bounds[0] - y) / self.bounds[0] * (self.map_dimensions['max_y'] - self.map_dimensions['min_y']) + self.map_dimensions['min_y'])
                                for x, y in positions]
        return normalized_positions

    #______________________________ callbacks  _________________________
    def odom_callback(self, data, robot_id):
        '''
        Takes odom msg and robot id, and creates boids if not created.
        Otherwise, updates the state of the boid.
        '''
        x = pose_msg_to_state(data)[:2]
        self.G.set_position(robot_id,x)
        # print(self.G.get_positions())

    def map_cb(self, gridmap):
        env = np.array(gridmap.data).reshape(gridmap.info.height, gridmap.info.width).T
        # Set avoid obstacles - The steer to avoid behavior (IN THE DICTIONARY) requires the map, resolution, and origin
        self.avoid_obstacles.set(data=env, 
                                resolution=gridmap.info.resolution, 
                                origin=[gridmap.info.origin.position.x, gridmap.info.origin.position.y])
        self.map_msg = gridmap         
            
    # def run(self, event):

    #     # check if graph is properly initialized with all positions
    #     if self.G.is_graph_init():        
            
    #         # print('in run')
    #         # get velocities from rendezvous
    #         vels = self.G.rendezvous(speed=0.1)
            
    #         for boid, v in vels.items():
    #             if not(self.G.is_stubborn(boid)):
    #                 self.publish_cmd_vel(boid, v)

    #     # #publish the formation
        # if self.boids_created:
        #     #publish the trajectory of each boid
        #     self.publish_boid_trajectory()

    def run(self, event):
        # print(f'----------------inside this -----------------------')
        if self.G.is_graph_init():        
            
            # Perform the task    
            self.task_function(self.G, self.task, self.task_args)

            if self.k > 0 and self.task == 'formation_consensus': # If there are stubborn nodes, update their goal.

                # Extract the last position of the stubborn agents - there are k stubborn agents
                prev_stubborn_pos = [self.G.positions[i] for i in range(self.n, self.n + self.k)]

                new_stubborn_pos = self.G.stubborn_agent.update_goal(self.stubborn_motion_type)

                #we need to publish veloites
                self.G.update_connectivity()
            # we need velocities instead of position.
            # positions = self.G.get_positions()
            vels = self.G.get_velocities()

            # Replace the velocities of the stubborn agents with the scale * (new position - old position)
            for i in range(self.n, self.n + self.k):
                vels[i] = self.scale_vel * (np.array(new_stubborn_pos[i - self.n]) - np.array(prev_stubborn_pos[i - self.n]))

            for boid, v in vels.items():
                # if not(self.G.is_stubborn(boid)):
                self.publish_cmd_vel(boid, v)

            self.rate.sleep()
    #_______________________________  Publishers and Viz  _________________________
    # Write a function that takes in a boid and cmd_vel and publishes it to the appropriate topic
    def publish_cmd_vel(self, boid, vel):
        # Make cmd_vel a Twist message
        # print(boid, vel)
        cmd_vel = Twist()
        cmd_vel.linear.x = vel[0]
        cmd_vel.linear.y = vel[1]
        # Publish to the appropriate topic
        self.pubs[boid].publish(cmd_vel)

    def publish_boid_trajectory(self):
        for i, boid in enumerate(self.boids):
            pose = PoseStamped()
            pose.header.frame_id = "map"
            pose.header.stamp = rospy.Time.now()
            pose.pose.position.x = boid.get_pos()[0]
            pose.pose.position.y = boid.get_pos()[1]
            pose.pose.position.z = 0
            #convert the yaw angle to a euler to quaternion
            quaternion = tf.transformations.quaternion_from_euler(0.0, 0.0, boid.get_theta())
            pose.pose.orientation.x = quaternion[0]
            pose.pose.orientation.y = quaternion[1]
            pose.pose.orientation.z = quaternion[2]
            pose.pose.orientation.w = quaternion[3]
        
            #the trajectory is a linestrip marker
            self.boid_traj[i].points.append(pose.pose.position)
            self.traj_pub[i].publish(self.boid_traj[i])
        pass


    def initialize_ros_components(self):
        # Initialize ROS subscribers and publishers
        #define a path message for each boid
        self.boid_path = [Path() for i in range(self.n_boids)]
        self.boid_traj = [Marker() for i in range(self.n_boids)]
        #define a publisher for the linestrip trajectory of each boid
        self.traj_pub = [rospy.Publisher('/robot_{}/trajectory'.format(i), Marker, queue_size=1)
                        for i in range(self.n_boids)]
        
        #create an array of different random RGBA colors to be used for each boid path trajectory
        self.traj_colors = [ColorRGBA(np.random.rand(), np.random.rand(), np.random.rand(), 1.0) for i in range(self.n_boids)]
        
        #define some basic attributes of the path message
        for i in range(self.n_boids):
            #basic path attributes
            self.boid_path[i].header.frame_id = "map"
            self.boid_path[i].header.stamp = rospy.Time.now()

            #basic marker trajectory attributes
            self.boid_traj[i].header.frame_id = "map"
            self.boid_traj[i].header.stamp = rospy.Time.now()
            self.boid_traj[i].type = Marker.LINE_STRIP
            self.boid_traj[i].action = Marker.ADD
            self.boid_traj[i].lifetime = rospy.Duration(423864)
            self.boid_traj[i].scale.x = 0.05
            self.boid_traj[i].color = self.traj_colors[i]
        
    def _visualize(self, event):
        self.boids_markers.markers = []

        # get a dict of positions as id: (x,y)
        positions = self.G.get_positions()
        n = self.G.get_num_nodes()

        # Extra pos and leader data from boids
        stubborn_list = [1 if self.G.is_stubborn(i) else 0 
                         for i in range(n)]

        # Ensure that all boids have been initialized in graph with proper positions
        if not(self.G.is_graph_init()):
            return
        
        for i in range(n):

            # print(f'positions: {positions[i]} {n} {stubborn_list}')
            # raise ValueError    

            if self.G.is_stubborn(i):
                print(f'{TextColors.RED}Stubborn: {i} {positions[i]}{TextColors.RESET}')

            # create boid markers
            marker = Marker(
                header=Header(frame_id="map"),
                type=Marker.SPHERE,
                action=Marker.ADD,
                pose=Pose(Point(*positions[i], 0), Quaternion(0, 0, 0, 1)),
                # red for leader, blue for normal
                color=ColorRGBA(stubborn_list[i], 0, 1-stubborn_list[i], 1),
                scale=Vector3(0.2, 0.2, 0.2),
                lifetime=rospy.Duration(0),
            )
            marker.id = i
            self.boids_markers.markers.append(marker)
        self.boids_markers_pub.publish(self.boids_markers)

        # edges
        edges = self.G.get_edges()
        edge_marker = Marker(
                header=Header(frame_id="map"),
                type=Marker.LINE_LIST,
                action=Marker.ADD,
                color=ColorRGBA(0.1, 0.7, 0.1, 1),
                scale=Vector3(0.1, 0.1, 0.1),
                lifetime=rospy.Duration(0),
                id = 0,
                ns = "lines"
            )
        pts = []
        for e in edges:
            u, v = positions[e[0]], positions[e[1]]
            pts.append(Point(u[0], u[1], 0))
            pts.append(Point(v[0], v[1], 0))
        edge_marker.points = pts
        self.edges_pub.publish(edge_marker)


        # publish goal 
        marker = Marker(
                header=Header(frame_id="map"),
                type=Marker.CYLINDER,
                action=Marker.ADD,
                pose=Pose(Point(*[self.goal[0], self.goal[1]], 0), Quaternion(0, 0, 0, 1)),
                # red for leader, blue for normal
                color=ColorRGBA(1, 1, 0, 0.4),
                
                scale=Vector3(self.goal_radius*2, self.goal_radius*2, 0.3),
                lifetime=rospy.Duration(0),
            )
        self.goal_pub.publish(marker)

        #___________________  Publish map  ___________________
        self.dilated_obs_pub.publish(self.map_msg)


if __name__ == '__main__':
    rospy.init_node('reynolds', anonymous=True)
    try:
        node = Reynolds()
        rospy.spin()
    except rospy.ROSInterruptException:
        pass


    #  roslaunch multi-robot-consensus formation_ctl.launch 